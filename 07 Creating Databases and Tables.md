# SERIAL

* A sequence is a special kind of database object that generates a sequence of integers
* Often used as the primary key column in a table
* It will create a sequence object and set the next value generated by the sequence as the default value for the column
* Perfect for primary key, because it logs unique integer entries for you automatically upon insertion
* If a row is later removed, the column with the SERIAL data type will not adjust, marking the fact that a row was removed from the sequence.
* Data types include smallserial, serial, and bigserial.





# CREATE

General Syntax:
```
CREATE TABLE table_name (
	column_name TYPE column_constraint,
	column_name TYPE column_constraint,
	column_name TYPE column_constraint,
	table_constraint table_constraint
	) INHERITS existing_table_name;
```

Example:
```
CREATE TABLE players (
	player_id SERIAL PRIMARY KEY,
	age SMALLINT NOT NULL
	);
```



# Creating new database in PostgreSQL

In PostgreSQL, under Databases, right click and select Create - Database.

Enter the name of the database, then click Save.

Right click on the new database created and refresh to ensure the connection is successful.

Right click on the new database created and select Query Tool.

Make sure Query Tool points to the correct database.


No need worry about indentation or spacing for queries.


```
CREATE TABLE account(
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(50) NOT NULL,
    email VARCHAR(250) UNIQUE NOT NULL,
    created_on TIMESTAMP NOT NULL,
    last_login TIMESTAMP
)
```

Note that you can only create a table one time. Otherwise, an error saying table already exists shows up.

```
CREATE TABLE job(
    job_id SERIAL PRIMARY KEY,
    job_name VARCHAR(200) UNIQUE NOT NULL
)
```

```
CREATE TABLE account_job(
    user_id INTEGER REFERENCES account(user_id),
    job_id INTEGER REFERENCES job(job_id),
    hire_date TIMESTAMP NOT NULL
)
```

Notice that for the table referencing the foreign key, you do not indicate as SERIAL. Instead you indicate it as INTEGER.

The constraint `REFERENCES table_name(primary_key)` indicates that this is a foreign key referencing to another table.





# INSERT

Allows you to add rows to table.

Syntax:
```
INSERT INTO table(column1, column2, ...)
VALUES
    (value1, value2, ...)
    (value1, value2, ...), ...;
```

Syntax for inserting values from another table:
```
INSERT INTO table(column1, column2, ...)
SELECT column1, column2, ...
FROM another_table
WHERE condition;
```

Note that inserted row values must match up for the table, including constraints and data type.

So if one of your constraints was that the column is not null, then you must provide a value as you insert, otherwise will get an error.

SERIAL columns do not need to be provided a value.

Example:

```
INSERT INTO account(username, password, email, created_on)
VALUES
('Jose', 'password', 'jose@mail.com', CURRENT_TIMESTAMP)
```

Run the query and it will show INSERT 0 1. This means row inserted successfully.

Any queries run to show the data within will need to be re-run for the new inserted data to show up.

Example to add new jobs:
```
INSERT INTO job(job_name)
VALUES
('Astronaut')
```

```
INSERT INTO job(job_name)
VALUES
('President')
```

Example to match job to account. Notice that you need to enter the values of the keys of the various user_id and job_id.

```
INSERT INTO account_job(user_id, job_id, hire_date)
VALUES
(1, 1, CURRENT_TIMESTAMP)
```

Have to make sure that when we're inserting something that has a foreign key constraint, that it actually exists in the other tables.

This is the exact kind of behavior and error you want.

Otherwise, we're doing some sort of link that doesn't actually exist.

These constraints will do things like stop information being inserted into it if it actually violates the constraints.





# UPDATE


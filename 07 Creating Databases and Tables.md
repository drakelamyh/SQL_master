# SERIAL

* A sequence is a special kind of database object that generates a sequence of integers
* Often used as the primary key column in a table
* It will create a sequence object and set the next value generated by the sequence as the default value for the column
* Perfect for primary key, because it logs unique integer entries for you automatically upon insertion
* If a row is later removed, the column with the SERIAL data type will not adjust, marking the fact that a row was removed from the sequence.
* Data types include smallserial, serial, and bigserial.





# CREATE

General Syntax:
```
CREATE TABLE table_name (
	column_name TYPE column_constraint,
	column_name TYPE column_constraint,
	column_name TYPE column_constraint,
	table_constraint table_constraint
	) INHERITS existing_table_name;
```

Example:
```
CREATE TABLE players (
	player_id SERIAL PRIMARY KEY,
	age SMALLINT NOT NULL
	);
```



# Creating new database in PostgreSQL

In PostgreSQL, under Databases, right click and select Create - Database.

Enter the name of the database, then click Save.

Right click on the new database created and refresh to ensure the connection is successful.

Right click on the new database created and select Query Tool.

Make sure Query Tool points to the correct database.


No need worry about indentation or spacing for queries.


```
CREATE TABLE account(
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(50) NOT NULL,
    email VARCHAR(250) UNIQUE NOT NULL,
    created_on TIMESTAMP NOT NULL,
    last_login TIMESTAMP
)
```

Note that you can only create a table one time. Otherwise, an error saying table already exists shows up.

```
CREATE TABLE job(
    job_id SERIAL PRIMARY KEY,
    job_name VARCHAR(200) UNIQUE NOT NULL
)
```

```
CREATE TABLE account_job(
    user_id INTEGER REFERENCES account(user_id),
    job_id INTEGER REFERENCES job(job_id),
    hire_date TIMESTAMP NOT NULL
)
```

Notice that for the table referencing the foreign key, you do not indicate as SERIAL. Instead you indicate it as INTEGER.

The constraint `REFERENCES table_name(primary_key)` indicates that this is a foreign key referencing to another table.





# INSERT

Allows you to add rows to table.

Syntax:
```
INSERT INTO table(column1, column2, ...)
VALUES
    (value1, value2, ...)
    (value1, value2, ...), ...;
```

Syntax for inserting values from another table:
```
INSERT INTO table(column1, column2, ...)
SELECT column1, column2, ...
FROM another_table
WHERE condition;
```

Note that inserted row values must match up for the table, including constraints and data type.

So if one of your constraints was that the column is not null, then you must provide a value as you insert, otherwise will get an error.

SERIAL columns do not need to be provided a value.

Example:

```
INSERT INTO account(username, password, email, created_on)
VALUES
('Jose', 'password', 'jose@mail.com', CURRENT_TIMESTAMP)
```

Run the query and it will show INSERT 0 1. This means row inserted successfully.

Any queries run to show the data within will need to be re-run for the new inserted data to show up.

Example to add new jobs:
```
INSERT INTO job(job_name)
VALUES
('Astronaut')
```

```
INSERT INTO job(job_name)
VALUES
('President')
```

Example to match job to account. Notice that you need to enter the values of the keys of the various user_id and job_id.

```
INSERT INTO account_job(user_id, job_id, hire_date)
VALUES
(1, 1, CURRENT_TIMESTAMP)
```

Have to make sure that when we're inserting something that has a foreign key constraint, that it actually exists in the other tables.

This is the exact kind of behavior and error you want.

Otherwise, we're doing some sort of link that doesn't actually exist.

These constraints will do things like stop information being inserted into it if it actually violates the constraints.





# UPDATE

Allows change of values in table.

General Syntax:

```
UPDATE table
SET col1 = value1,
col 2 = value2, ...
WHERE
    condition;
```

Example with WHERE. Can be done with or without the WHERE condition:

```
UPDATE account
SET last_login = CURRENT_TIMESTAMP
WHERE last_login IS NULL
```

Example based on another col:

```
UPDATE account
SET last_login = created_on
```

Example using another table's values, known as UPDATE JOIN:

```
UPDATE TableA
Set original_col = TableB.new_col
FROM TableB
WHERE TableA.id = TableB.id
```

```
UPDATE account_join
SET hire_date = account.created_on
FROM account
WHERE account_job.user_id = account.user_id
```

Return affected rows:

```
UPDATE account
SET last_login = created_on
RETURNING account_id, last_login
```

```
UPDATE account
SET last_login = CURRENT_TIMESTAMP
RETURNING email, created_on, last_login
```



# DELETE

Used to remove rows from table.

Example:

```
DELETE FROM table
WHERE row_id = 1
```

Delete rows based on presence in other tables

```
DELETE FROM tableA
USING tableB
WHERE tableA.id = tableB.id
```

Can delete all rows from table. Example:

```
DELETE FROM tableA
```

Example:

```
DELETE FROM job
WHERE job_name = 'Cowboy'
RETURNING job_id, job_name
```



# ALTER Table

Allows for changes to existing table structure, such as:
* Add, drop, rename columns
* Change column's data type
* Set DEFAULT values for columns
* Add CHECK constraints
* Rename table

Documentation: https://www.postgresql.org/docs/current/sql-altertable.html


General syntax:

```
ALTER TABLE table_name action
```

For adding columns:

```
ALTER TABLE table_name
ADD COLUMN new_col TYPE
```

Remove columns:

```
ALTER TABLE table_name
DROP COLUMN col_name
```

Alter constraints:

* Use SET to add and DROP to remove.

```
ALTER TABLE table_name
ALTER COLUMN col_name
SET DEFAULT value
```

```
ALTER TABLE table_name
ALTER COLUMN col_name
DROP DEFAULT
```

```
ALTER TABLE table_name
ALTER COLUMN col_name
SET NOT NULL
```

```
ALTER TABLE table_name
ALTER COLUMN col_name
DROP NOT NULL
```

```
ALTER TABLE table_name
ALTER COLUMN col_name
ADD CONSTRAINT constraint_name
```

Examples:

```
ALTER TABLE information
RENAME TO new_info
```

```
ALTER TABLE new_info
RENAME COLUMN person TO people
```

```
ALTER TABLE new_info
ALTER COLUMN people DROP NOT NULL
```



# DROP Table

